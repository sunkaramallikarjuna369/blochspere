<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Common States - The Bloch Sphere</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Concept 3: Common States</h1>
            <p class="subtitle">The Six Cardinal Points of the Bloch Sphere</p>
        </header>

        <nav class="nav-buttons">
            <a href="../02-mathematical-representation/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../04-physical-interpretation/index.html" class="btn btn-secondary">Next</a>
        </nav>

        <div class="section full-width">
            <h2>Interactive: Explore Common States</h2>
            <div id="canvas-container"></div>
            <div class="state-cards">
                <div class="state-card" data-state="0" onclick="selectState('0')">
                    <div class="state-name">|0⟩</div>
                    <div class="state-coords">(0, 0, 1)</div>
                </div>
                <div class="state-card" data-state="1" onclick="selectState('1')">
                    <div class="state-name">|1⟩</div>
                    <div class="state-coords">(0, 0, -1)</div>
                </div>
                <div class="state-card" data-state="+" onclick="selectState('+')">
                    <div class="state-name">|+⟩</div>
                    <div class="state-coords">(1, 0, 0)</div>
                </div>
                <div class="state-card" data-state="-" onclick="selectState('-')">
                    <div class="state-name">|-⟩</div>
                    <div class="state-coords">(-1, 0, 0)</div>
                </div>
                <div class="state-card" data-state="+i" onclick="selectState('+i')">
                    <div class="state-name">|+i⟩</div>
                    <div class="state-coords">(0, 1, 0)</div>
                </div>
                <div class="state-card" data-state="-i" onclick="selectState('-i')">
                    <div class="state-name">|-i⟩</div>
                    <div class="state-coords">(0, -1, 0)</div>
                </div>
            </div>
        </div>

        <div class="content-grid">
            <div class="section">
                <h2>1. Computational Basis</h2>
                <p>The Z-axis states form the computational basis:</p>
                <div class="formula">|0⟩ = [1, 0]<sup>T</sup></div>
                <p>θ = 0, φ = 0 → r⃗ = (0, 0, 1) — North Pole</p>
                <div class="formula">|1⟩ = [0, 1]<sup>T</sup></div>
                <p>θ = π, φ = 0 → r⃗ = (0, 0, -1) — South Pole</p>
                <div class="key-point">
                    <h4>Measurement Basis</h4>
                    <p>These are the states we typically measure in. A qubit collapses to |0⟩ or |1⟩ when measured.</p>
                </div>
            </div>

            <div class="section">
                <h2>2. Superposition States (X-axis)</h2>
                <p>Equal superpositions with real coefficients:</p>
                <div class="formula">|+⟩ = (|0⟩ + |1⟩)/√2</div>
                <p>θ = π/2, φ = 0 → r⃗ = (1, 0, 0) — +X Axis</p>
                <div class="formula">|-⟩ = (|0⟩ - |1⟩)/√2</div>
                <p>θ = π/2, φ = π → r⃗ = (-1, 0, 0) — -X Axis</p>
                <div class="key-point">
                    <h4>Hadamard Basis</h4>
                    <p>Created by applying the Hadamard gate to |0⟩ and |1⟩ respectively.</p>
                </div>
            </div>

            <div class="section">
                <h2>3. Phase States (Y-axis)</h2>
                <p>Equal superpositions with imaginary phase:</p>
                <div class="formula">|+i⟩ = (|0⟩ + i|1⟩)/√2</div>
                <p>θ = π/2, φ = π/2 → r⃗ = (0, 1, 0) — +Y Axis</p>
                <div class="formula">|-i⟩ = (|0⟩ - i|1⟩)/√2</div>
                <p>θ = π/2, φ = 3π/2 → r⃗ = (0, -1, 0) — -Y Axis</p>
                <div class="key-point">
                    <h4>Circular Polarization</h4>
                    <p>In photonic qubits, these correspond to right and left circular polarization.</p>
                </div>
            </div>

            <div class="section full-width">
                <h2>Complete Reference Table</h2>
                <table>
                    <thead>
                        <tr>
                            <th>State</th>
                            <th>Vector Form</th>
                            <th>Amplitude Form</th>
                            <th>(θ, φ)</th>
                            <th>Bloch (x, y, z)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>|0⟩</td>
                            <td>[1, 0]<sup>T</sup></td>
                            <td>1|0⟩ + 0|1⟩</td>
                            <td>(0, 0)</td>
                            <td>(0, 0, 1)</td>
                        </tr>
                        <tr>
                            <td>|1⟩</td>
                            <td>[0, 1]<sup>T</sup></td>
                            <td>0|0⟩ + 1|1⟩</td>
                            <td>(π, 0)</td>
                            <td>(0, 0, -1)</td>
                        </tr>
                        <tr>
                            <td>|+⟩</td>
                            <td>[1, 1]<sup>T</sup>/√2</td>
                            <td>(|0⟩ + |1⟩)/√2</td>
                            <td>(π/2, 0)</td>
                            <td>(1, 0, 0)</td>
                        </tr>
                        <tr>
                            <td>|-⟩</td>
                            <td>[1, -1]<sup>T</sup>/√2</td>
                            <td>(|0⟩ - |1⟩)/√2</td>
                            <td>(π/2, π)</td>
                            <td>(-1, 0, 0)</td>
                        </tr>
                        <tr>
                            <td>|+i⟩</td>
                            <td>[1, i]<sup>T</sup>/√2</td>
                            <td>(|0⟩ + i|1⟩)/√2</td>
                            <td>(π/2, π/2)</td>
                            <td>(0, 1, 0)</td>
                        </tr>
                        <tr>
                            <td>|-i⟩</td>
                            <td>[1, -i]<sup>T</sup>/√2</td>
                            <td>(|0⟩ - i|1⟩)/√2</td>
                            <td>(π/2, 3π/2)</td>
                            <td>(0, -1, 0)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="section full-width">
                <h2>Python Example</h2>
                <div class="code-block">
<pre>import numpy as np

# Define the six cardinal states
states = {
    '|0⟩': np.array([1, 0]),
    '|1⟩': np.array([0, 1]),
    '|+⟩': np.array([1, 1]) / np.sqrt(2),
    '|-⟩': np.array([1, -1]) / np.sqrt(2),
    '|+i⟩': np.array([1, 1j]) / np.sqrt(2),
    '|-i⟩': np.array([1, -1j]) / np.sqrt(2)
}

def state_to_bloch(state):
    """Convert state vector to Bloch coordinates."""
    rho = np.outer(state, np.conj(state))
    x = 2 * np.real(rho[0, 1])
    y = 2 * np.imag(rho[0, 1])
    z = np.real(rho[0, 0] - rho[1, 1])
    return (x, y, z)

print("State → Bloch Coordinates")
print("-" * 40)
for name, state in states.items():
    coords = state_to_bloch(state)
    print(f"{name}: ({coords[0]:.2f}, {coords[1]:.2f}, {coords[2]:.2f})")</pre>
                </div>
            </div>
        </div>

        <nav class="nav-buttons">
            <a href="../02-mathematical-representation/index.html" class="btn btn-secondary">Previous</a>
            <a href="../index.html" class="btn btn-primary">Home</a>
            <a href="../04-physical-interpretation/index.html" class="btn btn-secondary">Next</a>
        </nav>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let statePoints = {};
        let currentHighlight = null;
        
        const stateData = {
            '0': { theta: 0, phi: 0, color: 0x45b7d1, pos: [0, 0, 1] },
            '1': { theta: Math.PI, phi: 0, color: 0x45b7d1, pos: [0, 0, -1] },
            '+': { theta: Math.PI/2, phi: 0, color: 0xff6b6b, pos: [1, 0, 0] },
            '-': { theta: Math.PI/2, phi: Math.PI, color: 0xff6b6b, pos: [-1, 0, 0] },
            '+i': { theta: Math.PI/2, phi: Math.PI/2, color: 0x4ecdc4, pos: [0, 1, 0] },
            '-i': { theta: Math.PI/2, phi: 3*Math.PI/2, color: 0x4ecdc4, pos: [0, -1, 0] }
        };
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a2e);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(2.5, 2, 2.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            createBlochSphere();
            createStatePoints();
            addLighting();
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function createBlochSphere() {
            // Wireframe sphere
            const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
            const sphereMat = new THREE.MeshBasicMaterial({
                color: 0x00d4ff,
                wireframe: true,
                transparent: true,
                opacity: 0.15
            });
            scene.add(new THREE.Mesh(sphereGeo, sphereMat));
            
            // Equator
            const equatorGeo = new THREE.RingGeometry(0.99, 1.01, 64);
            const equatorMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
            const equator = new THREE.Mesh(equatorGeo, equatorMat);
            equator.rotation.x = Math.PI / 2;
            scene.add(equator);
            
            // Axes
            const axisLen = 1.4;
            addAxis(-axisLen, 0, 0, axisLen, 0, 0, 0xff6b6b);
            addAxis(0, -axisLen, 0, 0, axisLen, 0, 0x4ecdc4);
            addAxis(0, 0, -axisLen, 0, 0, axisLen, 0x45b7d1);
        }
        
        function createStatePoints() {
            const labels = {
                '0': '|0⟩', '1': '|1⟩', '+': '|+⟩', '-': '|-⟩', '+i': '|+i⟩', '-i': '|-i⟩'
            };
            
            for (const [key, data] of Object.entries(stateData)) {
                const pointGeo = new THREE.SphereGeometry(0.1, 16, 16);
                const pointMat = new THREE.MeshPhongMaterial({
                    color: data.color,
                    emissive: data.color,
                    emissiveIntensity: 0.3
                });
                const point = new THREE.Mesh(pointGeo, pointMat);
                point.position.set(...data.pos);
                scene.add(point);
                statePoints[key] = { mesh: point, material: pointMat };
                
                // Add label
                addLabel(labels[key], data.pos[0] * 1.3, data.pos[1] * 1.3, data.pos[2] * 1.3);
            }
        }
        
        function addAxis(x1, y1, z1, x2, y2, z2, color) {
            const geo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(x1, y1, z1),
                new THREE.Vector3(x2, y2, z2)
            ]);
            const mat = new THREE.LineBasicMaterial({ color: color });
            scene.add(new THREE.Line(geo, mat));
        }
        
        function addLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 64, 45);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(0.4, 0.2, 1);
            scene.add(sprite);
        }
        
        window.selectState = function(state) {
            // Reset all cards
            document.querySelectorAll('.state-card').forEach(card => card.classList.remove('active'));
            
            // Highlight selected card
            document.querySelector(`[data-state="${state}"]`).classList.add('active');
            
            // Reset all points
            for (const [key, data] of Object.entries(statePoints)) {
                data.mesh.scale.set(1, 1, 1);
                data.material.emissiveIntensity = 0.3;
            }
            
            // Highlight selected point
            if (statePoints[state]) {
                statePoints[state].mesh.scale.set(1.5, 1.5, 1.5);
                statePoints[state].material.emissiveIntensity = 0.8;
            }
            
            // Animate camera to view the state
            const pos = stateData[state].pos;
            const targetPos = new THREE.Vector3(pos[0] * 3, pos[1] * 3 + 1, pos[2] * 3);
        };
        
        function addLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const point = new THREE.PointLight(0xffffff, 1);
            point.position.set(5, 5, 5);
            scene.add(point);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
